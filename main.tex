\documentclass[12pt]{amsart}
\usepackage[utf8]{inputenc}
\usepackage{ae,aecompl,aeguill}	% pour utiliser << et >>
\usepackage[english]{babel}
\usepackage{times}
\usepackage[babel=true,kerning=true]{microtype} 

\begin{document}

\begin{abstract}
\end{abstract}

Our conjecture: if injectivity is not satisfied, then it's going to
show up in the associativity test of Froidure Pin.


Setup:

    we start with a set S with a distinguished element \1 (think
    blackboard bold 1), and operators pi_i: S -> S for i in I. We let
    the free monoid I^* act on the right on S through the operators
    pi_i. For u a word, we denote by \pi_u the corresponding operator.
    Let M be the image of \pi: u-> \pi_u, or equivalently the
    appropriate quotient of I^*.

    Our wish is to apply the Froidure Pin algorithm to M while
    identifying the right Cayley graph of M and that of its action on
    \1.M through the map:

        \1.  :   m  ->  \1.m

    We consider the shortlex section sl of this map: for all m in M,
    we let sl(m) be the shortlex word such that \1.m = 1.sl(m). By
    extension we define sl on any word. We define

        SL = { sl(m),  m in M }

Example:

    Let S = {1,2,3,4,5}, \1 =1, and consider the permutation
    (1,2),(3,4,5) as single operator. If we were to apply our Froidure
    Pin algorithm by just looking at the orbit of \1, we would blind
    ourselves from what's happening else where in S, and just find a
    proper quotient of M of size 2, generated by (1,2); therefore
    there would be no "associativity contradiction".

That's the first "mostly true" part: for the conjecture to make sense,
we need to assume that the action of M on \1.M to be faithful.

To handle the above example, we may replace \1 by the pair (1,3), and
let M act diagonally on pairs. Or take for \1 some larger base. The
extreme being to take \1 = (1,2,3,4,5), and let M act on 5-tuples;
this amounts to represent elements of M by transformations.

Proposition:

    Assume that the action of M on \1.M is faithful.
    Then the following are equivalent:

    (a)  \1. is injective
    (b)  for all i,f,g:       \1.f = \1.g implies (\1.i).f = (\1.i).g
    (c)  for all u,           (1.i).u = (1.i).sl(u) ;  same for all f
    (d)  for u in SL,         (\1.i).uj = (\1.i).sl(uj)

Remark: application of (d) to Froidure Pin

    Let's consider the step where we have some already computed vertex
    \1.u where u is in SL, and compute \1.u.j to see where it goes
    under the action of \pi_j. Assume that there is a collision:
    sl(uj) < uj in shortlex order.

    By Froidure Pin, we have already used associativity to compute the
    left actions on u and sl(uj), namely (\1.i).u and (\1.i).sl(uj)
    Usually, we don't bother computing the left action on \1.uj, since
    it's not a new element.

    But let's do it; namely calculate and compare (\1.i).uj and
    (1.i).sl(uj). If they are not equal, then stop: the map \1. is not
    injective.


Proof of the proposition:

(a) => (b) => (c): obvious.

(b) => (a):

We will use the following induction hypothesis HR_l:

    for all u, f,g with |u| â‰¤ l,    \1.f = \1.g  implies (\1.u).f = (\1.u).g

Note that HR_0 is trivial, HR_1 is (b) and (a) is HR_\infty.

Let l > 1 and assume that HR_l holds. Let us prove that HR_{l+1} holds.

Take v = ui of length l+1, and f and g such that \1.f=\1.g. By HR_1,

     \1 . (\pi_i f) = (\1.i). f = \1.(\pi_i g) = \1 . (\pi_i g)

Applying HR_l to \pi_i f and \pi_i g, we obtain:

       (\1.ui) . f  =  (\1.u) . (\pi_i f) = (\1.u) . (\pi_i g)
                    =  (\1.ui) . f,

as desired.


(c) => (b):   (\1.i).f = (\1.i).sl(f) = (\1.i).sl(g) = (\1.i).g


(d) => (c):

Let u = j_1 ... j_k. Then,

    (1.i).u = (1.i).sl()j_1j_2 ... j_k
            = (1.i).sl(j_1)j_2 ... j_k
            = (1.i).sl(j_1j_2) ... j_k
            = (1.i).sl(j_1j_2 ... j_k)
            = (1.i).sl(u)
\end{document}
